import * as ts from "typescript";
import {glob} from "glob";
import * as hb from 'handlebars'
import * as fs from "fs";

const defaultTemplate = `
/**
 * bahadrix/decwatch: Autogenerated file, do not edit
 */
{{#each imports}}
import {{this.className}} from "{{this.path}}";
{{/each}}

export default function () {
    return [
{{#each imports}}
        {{this.className}},
{{/each}}
    ]
}
`
type templateItem = {
    className: string
    path: string
}

export const DecWatch = {
    scanAndGenerate: async function (scanRoot: string, sourceRoot: string, generatedFilePath: string, allowedDecorators: string[], template: string = defaultTemplate) {

        let classes: templateItem[] = []
        const tsfiles = await glob(scanRoot + '/**/*.ts', {ignore: 'node_modules/**'})


        let program = ts.createProgram(tsfiles, {
            experimentalDecorators: true
        })

        for (const sourceFile of program.getSourceFiles()) {
            if (!sourceFile.fileName.startsWith(scanRoot)) continue;
            ts.forEachChild(sourceFile, n => {
                visit(n, sourceFile)
            })
        }

        /** visit nodes finding exported classes */
        function visit(node: ts.Node, sf: ts.SourceFile) {

            if (node.kind === ts.SyntaxKind.ClassDeclaration) {
                onClassDec(<ts.ClassDeclaration>node, sf);
            } else if (node.kind === ts.SyntaxKind.ModuleDeclaration) {
                ts.forEachChild(node, n => {
                    visit(n, sf)
                });
            }
        }


        const content = hb.compile(template)({imports: classes});
        fs.writeFileSync(generatedFilePath, content)

        function prepareImportPath(tsFilePath: string) {
            return tsFilePath
                .replace(sourceRoot, '@')
                .replace(/\.ts$/, '')
        }


        function onClassDec(node: ts.ClassDeclaration, sf: ts.SourceFile) {
            const name = node.name!.escapedText.toString()
            for (let modifier of node.modifiers!) {

                if (modifier.kind == ts.SyntaxKind.Decorator) {
                    const d = <ts.Decorator> modifier;

                    if (allowedDecorators.length > 0 && !allowedDecorators.includes(d.getText())) {

                        console.log(`${d.getText()} not in ${allowedDecorators}`)
                        continue
                    }


                    classes.push({
                        className: name.toString(),
                        path: prepareImportPath(sf.fileName)
                    })

                }
            }

        }
    }
}
